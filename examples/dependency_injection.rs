use hyper::http::HeaderValue;
use uuid::Uuid;
use volga::{
    App, HttpResult,
    middleware::{HttpContext, Next},
    headers::{Header, custom_headers},
    di::{Inject, Dc},
    ok, not_found
};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex}
};
use std::io::Error;
use volga::app::di::Container;

trait RequestIdGenerator: Send + Sync {
    fn generate_id(&self) -> String;
}

trait Cache: Send + Sync {
    fn get(&self, key: &str) -> Option<String>;
    fn set(&self, key: String, value: String);
}

/// In memory KV-storage
#[derive(Clone, Default)]
struct InMemoryCache {
    inner: Arc<Mutex<HashMap<String, String>>>
}

/// Per-request logger that holds a request id and reference to in memory storage
#[derive(Clone)]
struct RequestLog {
    request_id: String,
    cache: InMemoryCache,
    inner: Arc<Mutex<Vec<String>>>
}

#[derive(Clone, Default)]
struct UuidGenerator;

custom_headers! {
    (RequestId, "x-req-id")
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut app = App::new();
    
    // Register a singleton service that is available globally 
    let global_cache = InMemoryCache::default();
    app.add_singleton(global_cache);

    // Register a scoped service that will be available during the request lifetime
    app.add_scoped::<RequestLog>();
    
    // Register a scoped service that will be available during the request lifetime
    app.add_transient::<UuidGenerator>();
    
    // Each request uses a scoped logger to write some logs ("Request {ID} started", "Requests {ID} ended")
    // Each request has an ID generated by RequestIdGenerator and passed further as a request and response header
    // When the request ends all the logs are stored in the cache with a key in this format: "log_<request_id>" and can be read by GET
    app.use_middleware(log_request::<UuidGenerator>);
    
    app.map_get("/{id}", get_value::<InMemoryCache>);
    app.map_post("/{id}/{value}", set_value::<InMemoryCache>);
    
    app.run().await
}

async fn log_request<T: RequestIdGenerator + Inject>(mut ctx: HttpContext, next: Next) -> HttpResult {
    let log: RequestLog = ctx.resolve()?;
    
    ctx.request
        .headers_mut()
        .insert("x-req-id", HeaderValue::from_str(log.request_id.as_str()).unwrap());
    
    log.append("started");
    let response = next(ctx).await;
    log.append("ended");

    log.write();
    
    response
}

async fn get_value<T: Cache + Inject>(
    id: String,
    req_id: Header<RequestId>,
    cache: Dc<T>
) -> HttpResult {
    let item = cache.get(&id);
    match item { 
        Some(value) => ok!(value, [("x-req-id", req_id.to_string())]),
        None => not_found!([("x-req-id", req_id.to_string())])
    }
}

async fn set_value<T: Cache + Inject>(
    id: String, 
    value: String,
    req_id: Header<RequestId>,
    cache: Dc<T>
) -> HttpResult {
    cache.set(id, value);
    ok!([("x-req-id", req_id.to_string())])
}

impl Cache for InMemoryCache {
    fn get(&self, key: &str) -> Option<String> {
        self.inner
            .lock()
            .unwrap()
            .get(key)
            .cloned()
    }

    fn set(&self, key: String, value: String) {
        self.inner
            .lock()
            .unwrap()
            .insert(key, value);
    }
}

impl RequestLog {
    fn append(&self, log_entry: &str) {
        self.inner
            .lock()
            .unwrap()
            .push(format!("Request (ID {}): {log_entry}", self.request_id));
    }

    fn write(&self) { 
        let log = self.inner.lock().unwrap().join("\n");
        self.cache.set(format!("log_{}", self.request_id), log);
    }
}

/// Custom implementation of `Inject` trait that helps to construct the `RequestLog`
impl Inject for RequestLog {
    fn inject(container: &mut Container) -> Result<Self, Error> {
        let req_gen = container.resolve::<UuidGenerator>()?;
        let cache = container.resolve::<InMemoryCache>()?;
        Ok(Self { 
            request_id: req_gen.generate_id(), 
            inner: Default::default(),
            cache
        })
    }
}

impl RequestIdGenerator for UuidGenerator {
    fn generate_id(&self) -> String {
        Uuid::new_v4().to_string()
    }
}