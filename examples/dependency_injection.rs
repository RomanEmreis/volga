use uuid::Uuid;
use volga::{
    App, HttpResult, Json,
    di::{Inject, Container, Dc},
    error::Error,
    headers::HeaderValue,
    middleware::{HttpContext, Next},
};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex}
};

trait RequestIdGenerator: Send + Sync {
    fn generate_id(&self) -> String;
}

trait Cache: Send + Sync {
    fn get(&self, key: &str) -> Option<String>;
    fn set(&self, key: String, value: String);
}

/// In memory KV-storage
#[derive(Clone, Default)]
struct InMemoryCache {
    inner: Arc<Mutex<HashMap<String, String>>>
}

/// Per-request logger that holds a request id and reference to in memory storage
#[derive(Clone)]
struct RequestLog {
    request_id: String,
    cache: InMemoryCache,
    inner: Arc<Mutex<Vec<String>>>
}

#[derive(Clone, Default)]
struct UuidGenerator;

#[derive(serde::Deserialize)]
struct Item {
    id: String,
    value: String
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut app = App::new();
    
    let global_cache = InMemoryCache::default();
    app
        .add_singleton(global_cache)   // Register a singleton service that is available globally 
        .add_scoped::<RequestLog>()    // Register a scoped service that will be available during the request lifetime
        .add_transient::<UuidGenerator>();      // Register a scoped service that will be available during the request lifetime
    
    // Each request uses a scoped logger to write some logs ("Request {ID} started", "Requests {ID} ended")
    // Each request has an ID generated by RequestIdGenerator and passed further as a request and response header
    // When the request ends all the logs are stored in the cache with a key in this format: "log_<request_id>" and can be read by GET
    app
        .use_middleware(log_request::<UuidGenerator>)
        .map_get("/{id}", get_value::<InMemoryCache>)
        .map_post("/set", set_value::<InMemoryCache>);
    
    app.run().await
}

async fn log_request<T: RequestIdGenerator + Inject>(mut ctx: HttpContext, next: Next) -> HttpResult {
    let log: RequestLog = ctx.resolve().await?;
    let req_id = HeaderValue::from_str(log.request_id.as_str()).unwrap();
    ctx.request
        .headers_mut()
        .insert("x-req-id", req_id.clone());
    
    log.append("started");
    let mut response = next(ctx).await;
    log.append("ended");

    log.write();
    
    if let Ok(res) = &mut response {
        res.headers_mut()
            .insert("x-req-id", req_id);
    }
    response
}

async fn get_value<T: Cache + Inject>(id: String, cache: Dc<T>) -> Option<String> {
    cache.get(&id)
}

async fn set_value<T: Cache + Inject>(item: Json<Item>, cache: Dc<T>) {
    let item = item.into_inner();
    cache.set(item.id, item.value);
}

impl Cache for InMemoryCache {
    fn get(&self, key: &str) -> Option<String> {
        self.inner
            .lock()
            .unwrap()
            .get(key)
            .cloned()
    }

    fn set(&self, key: String, value: String) {
        self.inner
            .lock()
            .unwrap()
            .insert(key, value);
    }
}

impl RequestLog {
    fn append(&self, log_entry: &str) {
        self.inner
            .lock()
            .unwrap()
            .push(format!("Request (ID {}): {log_entry}", self.request_id));
    }

    fn write(&self) { 
        let log = self.inner.lock().unwrap().join("\n");
        self.cache.set(format!("log_{}", self.request_id), log);
    }
}

/// Custom implementation of `Inject` trait that helps to construct the `RequestLog`
impl Inject for RequestLog {
    async fn inject(container: &mut Container) -> Result<Self, Error> {
        let req_gen = container.resolve::<UuidGenerator>().await?;
        let cache = container.resolve::<InMemoryCache>().await?;
        Ok(Self { 
            request_id: req_gen.generate_id(), 
            inner: Default::default(),
            cache
        })
    }
}

impl RequestIdGenerator for UuidGenerator {
    fn generate_id(&self) -> String {
        Uuid::new_v4().to_string()
    }
}