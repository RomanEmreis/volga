//! Run with:
//!
//! ```no_rust
//! cargo run -p dependency_injection
//! ```

use uuid::Uuid;
use volga::{
    App,
    Json,
    di::{Inject, Singleton, Container, Dc, error::Error as DiError},
    error::Error,
    headers::HeaderValue,
    HttpRequest,
    HttpResponse,
    HttpResult,
    status
};

use std::{
    collections::HashMap,
    sync::{Arc, Mutex}
};

trait RequestIdGenerator: Send + Sync {
    fn generate_id(&self) -> String;
}

trait Cache: Send + Sync {
    fn get(&self, key: &str) -> Option<String>;
    fn set(&self, key: String, value: String);
}

/// In memory KV-storage
#[derive(Clone, Singleton)]
struct InMemoryCache {
    inner: Arc<Mutex<HashMap<String, String>>>
}

/// Per-request logger that holds a request id and reference to in memory storage
#[derive(Clone)]
struct RequestLog {
    request_id: String,
    cache: InMemoryCache,
    inner: Arc<Mutex<Vec<String>>>
}

#[derive(Default)]
struct UuidGenerator;

#[derive(serde::Deserialize)]
struct Item {
    id: String,
    value: String
}

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let mut app = App::new();

    app.map_err(error_handler);

    let global_cache = InMemoryCache { inner: Default::default() };
    app
        .add_singleton(global_cache)       // Register a singleton service that is available globally 
        .add_scoped::<RequestLog>()        // Register a scoped service that will be available during the request lifetime
        .add_transient::<UuidGenerator>(); // Register a scoped service that will be available during the request lifetime

    // Each request uses a scoped logger to write some logs ("Request {ID} started", "Requests {ID} ended")
    // Each request has an ID generated by RequestIdGenerator and passed further as a request and response header
    // When the request ends all the logs are stored in the cache with a key in this format: "log_<request_id>" and can be read by GET
    app
        .tap_req(set_req_id)
        .map_ok(set_resp_id)
        .map_get("/{id}", get_value::<InMemoryCache>)
        .map_post("/set", set_value::<InMemoryCache>);

    app.run().await
}

async fn set_req_id(mut req: HttpRequest, log: Dc<RequestLog>) -> HttpRequest {
    let req_id = HeaderValue::from_str(log.request_id.as_str()).unwrap();
    req.headers_mut().insert("x-req-id", req_id.clone());
    log.append("started");
    req
}

async fn set_resp_id(mut resp: HttpResponse, log: Dc<RequestLog>) -> HttpResponse {
    log.append("ended");
    let req_id = HeaderValue::from_str(log.request_id.as_str()).unwrap();
    resp.headers_mut().insert("x-req-id", req_id);
    log.write();
    resp
}

async fn get_value<T: Cache + Inject>(id: String, cache: Dc<T>) -> Option<String> {
    cache.get(&id)
}

async fn set_value<T: Cache + Inject>(Json(item): Json<Item>, cache: Dc<T>) {
    cache.set(item.id, item.value);
}

async fn error_handler(log: Dc<RequestLog>, error: Error) -> HttpResult {
    log.append(&format!("An Error occurred: {error:#}"));
    status!(500, "Internal Server Error", [
        ("x-req-id", &log.request_id)
    ])
}

impl Cache for InMemoryCache {
    fn get(&self, key: &str) -> Option<String> {
        self.inner
            .lock()
            .unwrap()
            .get(key)
            .cloned()
    }

    fn set(&self, key: String, value: String) {
        self.inner
            .lock()
            .unwrap()
            .insert(key, value);
    }
}

impl RequestLog {
    fn append(&self, log_entry: &str) {
        self.inner
            .lock()
            .unwrap()
            .push(format!("Request (ID {}): {log_entry}", self.request_id));
    }

    fn write(&self) {
        let log = self.inner.lock().unwrap().join("\n");
        self.cache.set(format!("log_{}", self.request_id), log);
    }
}

/// Custom implementation of the ` Inject ` trait that helps to construct the `RequestLog`
impl Inject for RequestLog {
    fn inject(container: &Container) -> Result<Self, DiError> {
        // We don't need to own this, and it's not implement a Clone, so we can resolve a shared pointer
        let req_gen = container.resolve_shared::<UuidGenerator>()?;
        // Since we need to own ity, and it's a clonable struct, it is fine to resolve as a clone
        let cache = container.resolve::<InMemoryCache>()?;
        
        Ok(Self {
            request_id: req_gen.generate_id(),
            inner: Default::default(),
            cache
        })
    }
}

impl RequestIdGenerator for UuidGenerator {
    fn generate_id(&self) -> String {
        Uuid::new_v4().to_string()
    }
}