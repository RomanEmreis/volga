//! Utilities for private cookies

use cookie::{CookieJar, PrivateJar, Key};
use futures_util::future::{ready, Ready};
use crate::{
    error::Error,
    di::container::Container,
    headers::{HeaderMap},
    http::{
        endpoints::args::{FromPayload, Payload, Source},
        cookie::{get_cookies}
    },
};

/// Represents a cryptographic pass key for [`PrivateCookies`]
#[derive(Clone)]
pub struct PrivateKey(Key);

/// Represents private HTTP cookies
pub struct PrivateCookies(PrivateKey, CookieJar);

impl Default for PrivateKey {
    #[inline]
    fn default() -> Self {
        Self::from(&[])
    }
}

impl PrivateKey {
    /// Creates a new [`PrivateKey`] from a 512-bit cryptographically random string.
    ///
    /// See also [`Key::from`]
    #[inline]
    pub fn from(bytes: &[u8]) -> Self {
        Self(Key::from(bytes))
    }

    /// Generates signing/encryption keys from a secure, random source. 
    /// Keys are generated nondeterministically.
    ///
    /// See also [`Key::generate`]
    #[inline]
    pub fn generate() -> Self {
        Self(Key::generate())
    }
}

impl PrivateCookies {
    /// Creates a new [`PrivateCookies`]
    #[inline]
    pub fn new(key: PrivateKey) -> Self {
        Self(key, CookieJar::default())
    }
    
    /// Creates a new [`PrivateCookies`] from [`HeaderMap`]
    #[inline]
    pub fn from_headers(key: PrivateKey, headers: &HeaderMap) -> Self {
        let mut jar = CookieJar::new();
        let mut private_jar = jar.private_mut(&key.0);
        for cookie in get_cookies(headers) {
            if let Some(cookie) = private_jar.decrypt(cookie) {
                private_jar.add_original(cookie);
            }
        }
        Self(key, jar)
    }

    /// Unwraps the inner jar and the pass key.
    #[inline]
    pub fn into_parts(self) -> (PrivateKey, CookieJar) {
        (self.0, self.1)
    }

    /// Returns a reference to the cookie inside the private jar by `name`
    /// and authenticates and decrypts the cookie's value, returning a [`Cookie`] with the decrypted value. 
    /// If the cookie cannot be found, or the cookie fails to authenticate or decrypt, `None` is returned.
    pub fn get(&self, name: &str) -> Option<cookie::Cookie<'static>> {
        self.private().get(name)
    }

    /// Adds a cookie. 
    /// The cookie's value is encrypted with authenticated encryption assuring confidentiality, integrity, and authenticity.
    #[allow(clippy::should_implement_trait)]
    pub fn add<C: Into<cookie::Cookie<'static>>>(mut self, cookie: C) -> Self {
        self.private_mut().add(cookie);
        self
    }

    /// Removes a cookie from the private jar.
    ///
    /// For correct removal, the passed in cookie must contain the same path 
    /// and domain as the cookie that was initially set.
    pub fn remove<C: Into<cookie::Cookie<'static>>>(mut self, cookie: C) -> Self {
        self.private_mut().remove(cookie);
        self
    }

    /// Authenticates and decrypts the cookie, returning the plaintext version if decryption succeeds or `None` otherwise. 
    /// Authentication and decryption always succeed if a cookie was generated by a [`PrivateCookies`] with the same key as self.
    pub fn decrypt(&self, cookie: cookie::Cookie<'static>) -> Option<cookie::Cookie<'static>> {
        self.private().decrypt(cookie)
    }

    /// Returns an iterator over all the cookies present in this jar.
    pub fn iter(&self) -> impl Iterator<Item = &cookie::Cookie<'static>> + '_ {
        self.1.iter()
    }

    #[inline]
    fn private(&self) -> PrivateJar<&'_ CookieJar> {
        self.1.private(&self.0.0)
    }

    #[inline]
    fn private_mut(&mut self) -> PrivateJar<&'_ mut CookieJar> {
        self.1.private_mut(&self.0.0)
    }
}

impl FromPayload for PrivateCookies {
    type Future = Ready<Result<Self, Error>>;

    #[inline]
    fn from_payload(payload: Payload) -> Self::Future {
        let Payload::Parts(parts) = payload else { unreachable!() };
        let container = Container::try_from(parts)
            .expect("DI Container must be provided");

        ready(container
            .resolve::<PrivateKey>()
            .map(|key| PrivateCookies::from_headers(key, &parts.headers)))
    }

    #[inline]
    fn source() -> Source {
        Source::Parts
    }
}

#[cfg(test)]
mod tests {
    use crate::di::ContainerBuilder;
    use super::*;
    use crate::headers::{COOKIE, SET_COOKIE};
    use crate::http::cookie::set_cookies;

    #[test]
    fn it_creates_cookies_from_empty_headers() {
        let key = PrivateKey::generate();
        let cookies = PrivateCookies::new(key);
        assert_eq!(cookies.iter().count(), 0);
    }

    #[test]
    fn it_creates_cookies() {
        let key = PrivateKey::from(
            b"f3d9e2a44c6b172a1ea9b9d05e5fe1bcaa8679d032ccae271c503af9618bb2ef7c4e51452dbfcd96f6e9c9d09166a3de77e");
        let cookies = PrivateCookies::new(key.clone());
        let cookies = cookies.add(("session", "abc123"));

        let mut headers = HeaderMap::new();
        set_cookies_for_request(cookies.1, &mut headers);

        let cookies = PrivateCookies::from_headers(key, &headers);
        let cookie = cookies.get("session").expect("Cookie should exist");

        assert_eq!(cookie.value(), "abc123");
    }

    #[test]
    fn it_creates_from_multiple_cookies() {
        let key = PrivateKey::generate();
        let cookies = PrivateCookies::new(key.clone());
        let cookies = cookies
            .add(("session", "abc123"))
            .add(("user", "john"))
            .add(("theme", "dark"));

        let mut headers = HeaderMap::new();
        set_cookies_for_request(cookies.1, &mut headers);

        let cookies = PrivateCookies::from_headers(key, &headers);

        assert_eq!(cookies.get("session").unwrap().value(), "abc123");
        assert_eq!(cookies.get("user").unwrap().value(), "john");
        assert_eq!(cookies.get("theme").unwrap().value(), "dark");
    }

    #[test]
    fn it_adds_and_removes_cookies() {
        let key = PrivateKey::generate();
        let mut cookies = PrivateCookies::new(key);

        // Add a new cookie
        cookies = cookies.add(cookie::Cookie::new("test", "value"));
        assert_eq!(cookies.get("test").unwrap().value(), "value");

        // Remove a cookie
        cookies = cookies.remove(cookie::Cookie::new("test", ""));
        assert!(cookies.get("test").is_none());
    }

    #[test]
    fn it_sets_cookies_to_headers() {
        let key = PrivateKey::generate();
        let mut cookies = PrivateCookies::new(key);
        cookies = cookies.add(cookie::Cookie::new("session", "xyz789"));

        let mut headers = HeaderMap::new();
        set_cookies(cookies.1, &mut headers);

        let cookie_header = headers.get(SET_COOKIE).expect("Cookie header should be set");
        assert!(cookie_header.to_str().unwrap().contains("session"));
    }

    #[tokio::test]
    async fn it_extracts_from_payload() {
        use hyper::Request;

        let key = PrivateKey::generate();
        let cookies = PrivateCookies::new(key.clone());
        let cookies = cookies.add(("test", "value"));

        let mut headers = HeaderMap::new();
        set_cookies_for_request(cookies.1, &mut headers);

        let mut container = ContainerBuilder::new();
        container.register_singleton(key);
        let container = container.build();

        let mut request = Request::builder()
            .extension(container.create_scope())
            .body(())
            .unwrap();

        request.headers_mut().extend(headers);

        let (parts, _) = request.into_parts();
        let payload = Payload::Parts(&parts);

        let cookies = PrivateCookies::from_payload(payload).await.unwrap();

        assert_eq!(cookies.get("test").unwrap().value(), "value");
    }

    #[test]
    fn if_return_parts_source() {
        assert_eq!(PrivateCookies::source(), Source::Parts);
    }

    fn set_cookies_for_request(jar: CookieJar, headers: &mut HeaderMap) {
        for cookie in jar.delta() {
            if let Ok(header_value) = cookie.encoded().to_string().parse() {
                headers.append(COOKIE, header_value);
            }
        }
    }
}